---
alwaysApply: true
priority: CRITICAL
nonNegotiable: true
---

# CRITICAL RULES - NON-NEGOTIABLE

## RULE 1: ALWAYS Read Documentation FIRST
- Before ANY code generation, check `.cursor/docs/net6/` for equivalents
- Never guess class names, namespaces, or DLL references
- If documentation is unclear, ask the user - never invent
- Search `.cursor/docs/net4/` only to understand OLD patterns, not for code generation

## RULE 2: Project Structure is MANDATORY
Follow the exact structure from `critical-patterns-learned.md`:
```
BACK/{module}/{ProgramName}Back/
BACK/{module}/{ProgramName}BackResources/
COMMON/{module}/{ProgramName}Common/
SERVICE/{module}/{ProgramName}Service/
FRONT/{ProgramName}Model/
FRONT/{ProgramName}FrontResources/
FRONT/{ProgramName}Front/
```
**VIOLATIONS:** Stop work, ask user for clarification.

## RULE 3: Logger & Activity PLACEMENT is STRICT
- Logger: **Back project ONLY**, inherit `R_NetCoreLoggerBase<Logger{ProgramName}>`
- Activity: **Back project ONLY**, inherit `R_ActivitySourceBase`
- **NEVER** put in Common project
- **NEVER** create custom implementations
- **VIOLATIONS:** Reject code generation, cite rule

## RULE 4: DLL References are VERIFIED
- All references must exist in `.cursor/docs/net6/`
- Use exact names: `R_APIBackEnd`, `R_CommonFrontBackAPI`, etc.
- **NEVER** invent new DLL names
- Validate in `.csproj` files before suggesting code

## RULE 5: Variable Naming is NON-NEGOTIABLE
- `[Inject]` properties: `private IType PropertyName { get; set; } = default!;` (PascalCase)
- Private fields: `private Type _propertyName;` (underscore + snake_case, NO type prefix)
- Public properties: `public Type PropertyName { get; set; }` (PascalCase)
- Local variables: `Type l{typePrefix}VariableName;` (always)
- Method parameters: `Type p{typePrefix}ParameterName;`
- **VIOLATIONS:** Correct immediately or refuse to proceed

## RULE 6: Resource Files LOCATION
- All resources in **root folder** of resource projects
- **NEVER** in subfolders
- Consolidated: Multiple programs share same resource files
- **VIOLATIONS:** Flag and request correction

## RULE 7: Interface Pattern is MANDATORY
- Use `R_IServiceCRUDAsyncBase<{ProgramName}DTO>` - NEVER `R_IServiceCRUDBase`
- Pattern: `GetList()` returns `IAsyncEnumerable<DTO>`
- Pattern: `GetAnything()` returns `Task<{ProgramName}ResultDTO<DTO>>`
- **VIOLATIONS:** Reject code, cite exact pattern from rules

## RULE 8: Streaming Context REQUIRED for List Methods
- Frontend: Use `R_FrontContext.R_SetStreamingContext()` for custom parameters
- Backend: Use `R_Utility.R_GetStreamingContext<Type>(ContextConstant.Key)`
- Method naming: `GetList{Description}()` (interface), `GetList{Description}Async()` (impl)
- **VIOLATIONS:** Reject code pattern, enforce correct usage

## RULE 9: No R_FrontGlobalVar in ViewModels
- **NEVER** use `R_FrontGlobalVar` in ViewModel classes
- Inject `IClientHelper` in .razor.cs ONLY
- Pass values as parameters to ViewModel methods
- **VIOLATIONS:** Reject code, enforce IClientHelper pattern

## RULE 10: Conductor Source DEPENDS on Control
- Grid CRUD operations: `R_ConductorGridSource="@_conductorGridRef"`
- Form access control: `R_ConductorSource="@_conductorRef"`
- No source: Component always enabled (independent functionality)
- **VIOLATIONS:** Explain correct usage, refuse wrong pattern

## RULE 11: Database Connection Pattern
```csharp
R_Db? loDb = null;
try
{
    loDb = new R_Db();
    using var loConn = await loDb.GetConnectionAsync();
    using var loCmd = loDb.GetCommand();
    loDb.R_AddCommandParameter(loCmd, "@PARAM", DbType.String, size, value);
    var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, true);
}
finally
{
    if (loDb != null) { loDb = null; }
}
```
- **MUST use:** `using var` for connections/commands
- **MUST use:** `loDb.R_AddCommandParameter()` - never `AddDbCommandParameter`
- **MUST have:** `loDb = null` in finally block
- **VIOLATIONS:** Reject code pattern, enforce compliance

## RULE 12: Sub-Programs are INTEGRATED
- SAM00110 does NOT get separate projects
- Same `SAM00100Model/`, `SAM00100Front/`, `SAM00100FrontResources/`
- Share Common project: `SAM00100Common/`
- **Wrong:** Creating `SAM00110Model/`, `SAM00110Front/` separate projects
- **VIOLATIONS:** Stop, explain consolidation requirement

## RULE 13: Navigation Components CORRECT USAGE
- `R_PredefinedDock`: Shown on page load, cannot close
- `R_Detail`: On click, can close
- `R_Popup`: For R_Page components in modals ONLY
- `R_Lookup`: For lookup pattern (selecting records)
- `R_Find`: For finding/selecting records
- MessageBox: Use `MessageBoxService`, NOT `R_Popup`
- **NEVER use R_Button for navigation**
- **VIOLATIONS:** Reject code, explain correct component

## RULE 14: Service Layer R_BackGlobalVar CORRECT USAGE
- IClientHelper data automatically set by `R_BackGlobalVar`
- **DO:** `var lcCompanyId = R_BackGlobalVar.COMPANY_ID;`
- **DON'T:** Set R_BackGlobalVar manually
- **DON'T:** Use streaming context for IClientHelper data
- Custom parameters only: Use streaming context in Controller/ViewModel
- **VIOLATIONS:** Reject pattern, enforce correct approach

## RULE 15: No Hardcoded Error Messages
- Retrieve errors from resource files
- Pattern: `R_Utility.R_GetError(typeof(Resources_Dummy_Class), pcErrorId)`
- Store all messages in `.resx` files
- **VIOLATIONS:** Flag all hardcoded messages, require resource-based approach

## RULE 16: Build Order is MANDATORY
Backend:
```
1. {ProgramName}Common
2. {ProgramName}BackResources
3. {ProgramName}Back
4. {ProgramName}Service
5. BIMASAKTI_GS_API
```
Frontend:
```
1. {ProgramName}Common
2. {ProgramName}FrontResources
3. {ProgramName}Model
4. {ProgramName}Front
5. BlazorMenu
```
- **VIOLATIONS:** Warn about compilation failures if order violated

## RULE 17: Batch Processing REQUIREMENTS
- Implement `R_IProcessProgressStatus`
- Deserialize with: `R_NetCoreUtility.R_DeserializeObjectFromByte<T>()`
- **NEVER:** `R_Utility.Deserialize<T>()`
- Add references: `R_BlazorFrontEnd.Excel`, `R_ProcessAndUploadFront`
- **VIOLATIONS:** Reject incomplete batch implementation

## RULE 18: R_SaveBatch Location is STRICT
- Call on `R_Grid` component: `await _gridRef.R_SaveBatch();`
- **NEVER** on `R_ConductorGrid`
- **VIOLATIONS:** Flag error, explain correct component

## RULE 19: Code Generation Workflow
1. **ALWAYS** check `.cursor/docs/net6/` first
2. If not found, check `.cursor/docs/net4/` for understanding only
3. If still unclear, **ASK THE USER** - never invent
4. Generate code matching documented patterns exactly
5. Include citations: `// Based on pattern from critical-patterns-learned.md`

## RULE 20: Error Handling for AI Assistant
- **First attempt:** Fix straightforward errors (missing using, typos)
- **Second attempt:** Try alternative approaches (references, syntax)
- **Third attempt:** ASK THE USER for solution
- **NEVER:** Comment out code as "fix"
- **VIOLATIONS:** Maintain code quality standards

## RULE 21: R_CONDUCTOR USAGE - CRITICAL DISTINCTION
**CRITICAL:** R_Conductor is ONLY for CRUD operations, NOT for inquiry programs

### When to Use R_Conductor
- **CRUD Programs:** Add, Edit, Delete, Save, Cancel operations
- **GridType.Navigator:** For grids with conductor-driven CRUD
- **Form Controls:** When you need Add/Edit/Delete buttons

### When NOT to Use R_Conductor
- **Inquiry Programs:** Read-only data display (like FAI00120)
- **GridType.Original:** For inquiry-only grids
- **Simple Forms:** Just displaying and filtering data

### R_Conductor Pattern
```csharp
// ONLY for CRUD programs
<R_Conductor @ref="@_conductorRef"
             R_ViewModel="@viewModel"
             R_Display="Conductor_DisplayMethod"
             R_IsHeader="true"
             R_ServiceGetRecord="@Conductor_ServiceGetRecord">
</R_Conductor>
```

### Inquiry Program Pattern (No Conductor)
```csharp
// For inquiry programs - NO R_Conductor needed
<R_Grid @ref="@_gridRef"
        DataSource="@viewModel.DataList"
        R_GridType="@R_eGridType.Original"
        R_ServiceGetListRecord="@Grid_ServiceGetListRecord">
</R_Grid>
```

**VIOLATIONS:** Using R_Conductor for inquiry programs, using GridType.Navigator without conductor

## RULE 22: WARNING HANDLING - MANDATORY
**CRITICAL:** Never ignore warnings in projects - address ALL warnings found

### Warning Classification
- **CODE WARNINGS:** Must be fixed (compiler, nullable, unused variables, etc.)
- **EXTERNAL WARNINGS:** Document and explain why they cannot be fixed
- **INFRASTRUCTURE WARNINGS:** Document as acceptable (NuGet connectivity, SDK conflicts)

### Warning Response Protocol
1. **First:** Identify warning type and source
2. **Code Warnings:** Fix immediately - no exceptions
3. **External Warnings:** Document in build report with explanation
4. **Never:** Claim "warnings are acceptable" without classification
5. **Always:** Report warning count and types in build summary

## RULE 23: DATA STATE SEPARATION - MANDATORY
**CRITICAL:** All data state must be in ViewModel, not in Razor.cs code-behind

### State Management Rules
- **UI State Only in Razor.cs:** Component references (`R_Grid? _gridRef`), UI-specific state
- **Data State in ViewModel:** All business data, form state, tracking variables
- **No Data State in Razor.cs:** Never store business data in code-behind

### Correct Pattern
```csharp
// Razor.cs - UI state only
private R_Grid<DTO>? _gridRef;
private R_TextBox? _txtField;

// ViewModel - All data state
public string FieldValue { get; set; }
public bool MustRefresh { get; set; }
public string LastValue { get; set; }
```

### Violations
- ❌ Storing form data in Razor.cs private fields
- ❌ Business logic state in code-behind
- ❌ Data tracking variables in Razor.cs

### Build Report Format
```
BUILD SUMMARY - Project: {ProjectName}
✓ Compilation: SUCCESS
⚠ Warnings: {Count} found
  - Code Warnings: {Count} (FIXED/NEEDS FIXING)
  - External Warnings: {Count} (DOCUMENTED)
  - Infrastructure Warnings: {Count} (ACCEPTABLE)
```

**VIOLATIONS:** Ignoring warnings, not classifying warning types, claiming "warnings are fine" without analysis

## RULE 24: MANDATORY BUILD VALIDATION - NON-NEGOTIABLE
**CRITICAL:** After generating/modifying ANY code, ALWAYS build to verify no errors

### Build Requirements by Project Type
**Backend Build Order:**
```bash
dotnet build "{ProgramName}Common"
dotnet build "{ProgramName}BackResources"
dotnet build "{ProgramName}Back"
dotnet build "{ProgramName}Service"
dotnet build "BIMASAKTI_GS_API"
```

**Frontend Build Order:**
```bash
dotnet build "{ProgramName}Common"
dotnet build "{ProgramName}FrontResources"
dotnet build "{ProgramName}Model"
dotnet build "{ProgramName}Front"
dotnet build "BlazorMenu"
```

### Build Validation Steps
1. **Before claiming code is complete:** Must execute build command
2. **If build succeeds:** Report "✓ Build successful - no errors"
3. **If build fails:** Report ALL error messages verbatim
4. **If build fails 1st time:** Attempt fix (Rule #20, Attempt 1)
5. **If build fails 2nd time:** Try alternative approach (Rule #20, Attempt 2)
6. **If build fails 3rd time:** ASK USER for solution (Rule #20, Attempt 3)

### Error Reporting Format
```
BUILD FAILURE - Project: {ProjectName}

Error CS####: {Full error message}
  Location: {FileName}:{LineNumber}:{ColumnNumber}
  Details: {Description}

Fix attempted: {What was tried}
Status: [FIXED] [AWAITING USER INPUT]
```

### What MUST Be Checked
- [ ] No compilation errors (CS####)
- [ ] No missing using statements
- [ ] No missing DLL references
- [ ] No type mismatches
- [ ] All projects in correct build order
- [ ] No syntax errors
- [ ] No missing project references in .csproj

### When Build Validation FAILS
- **Do NOT:** Say "code is ready" without building
- **Do NOT:** Claim "should work" without verifying
- **Do NOT:** Suggest "user will fix the errors"
- **MUST:** Build first, report results, fix or ask

### Build Validation is MANDATORY for:
- All new file generation
- All code modifications
- All .csproj changes
- All reference additions
- All pattern implementations
- Final code submission
---

# ENFORCEMENT ACTIONS

When rules are violated:

1. **Stop code generation immediately**
2. **Cite the specific rule number**
3. **Explain the violation**
4. **Provide correct pattern from documentation**
5. **Ask for user confirmation before proceeding**

**Non-negotiable = NO EXCEPTIONS, NO SHORTCUTS**

## RULE 25: EXCEPTION HANDLING PATTERN - MANDATORY
**CRITICAL:** All methods must use the standard R_Exception pattern

### Exception Handling Rules
- **Standard Pattern:** Use `var loEx = new R_Exception();`
- **Try/Catch:** Wrap code in try/catch with `loEx.Add(ex);`
- **End with:** `loEx.ThrowExceptionIfErrors();`
- **No Custom Patterns:** Never use custom exception handling

### Correct Pattern
```csharp
public async Task MethodName()
{
    var loEx = new R_Exception();
    
    try
    {
        // Your code here
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }
    
    loEx.ThrowExceptionIfErrors();
}
```

### Violations
- ❌ Using custom exception handling patterns
- ❌ Not using R_Exception standard pattern
- ❌ Missing try/catch blocks

## RULE 26: GRID DATA BINDING PATTERN - MANDATORY
**CRITICAL:** Grid data must flow through ViewModel properties, not return values

### Correct Data Flow
1. **Grid requests data** → `R_ServiceGetListRecord` is called
2. **ViewModel populates property** → `GetDataAsync()` fills `DataList` property
3. **Grid receives data** → `eventArgs.ListEntityResult = _viewModel.DataList`

### ViewModel Method Pattern
```csharp
// ✅ CORRECT - Populate ViewModel property
public async Task GetDataAsync(FilterRequest poRequest)
{
    var loResult = await _model.GetDataAsync(poRequest);
    if (loResult.Data != null)
    {
        DataList.Clear();
        DataList = new ObservableCollection<DTO>(loResult.Data);
    }
}

// ❌ WRONG - Returning data
public async Task<ObservableCollection<DTO>> GetDataAsync(FilterRequest poRequest)
{
    var loResult = await _model.GetDataAsync(poRequest);
    return new ObservableCollection<DTO>(loResult.Data);
}
```

### Grid Service Method Pattern
```csharp
// ✅ CORRECT - Assign from ViewModel property
public async Task R_ServiceGetListRecord(R_ServiceGetListRecordEventArgs eventArgs)
{
    var loRequest = new FilterRequest { /* parameters */ };
    await _viewModel.GetDataAsync(loRequest); // Populates ViewModel property
    eventArgs.ListEntityResult = _viewModel.DataList; // Assign to grid
}
```

### Violations
- ❌ Returning collections instead of populating properties

## RULE 27: STREAMING CONTEXT OPTIMIZATION - MANDATORY
**CRITICAL:** Only use streaming context for custom parameters, not system parameters value from ClientHelper

### System Parameters - ClientHelper (Auto-handled)
- **CCOMPANY_ID:** Available via `R_BackGlobalVar.COMPANY_ID`
- **CUSER_ID:** Available via `R_BackGlobalVar.USER_ID`
- **CLANG_ID:** Available via `R_BackGlobalVar.CULTURE`

### Custom Parameters (Use Streaming Context)
- **CSOFT_PERIOD:** Use `R_Utility.R_GetStreamingContext<string>(ContextConstants.SOFT_PERIOD)`
- **CTRANSACTION_CODE:** Use `R_Utility.R_GetStreamingContext<string>(ContextConstants.TRANSACTION_CODE)`
- **CDEPT_CODE:** Use `R_Utility.R_GetStreamingContext<string>(ContextConstants.DEPT_CODE)`

### Correct Pattern
```csharp
// Controller - Get system parameters from R_BackGlobalVar
var lcCompanyId = R_BackGlobalVar.COMPANY_ID;
var lcUserId = R_BackGlobalVar.USER_ID;
var lcLangId = R_BackGlobalVar.CULTURE;

// Get custom parameters from streaming context
var lcSoftPeriod = R_Utility.R_GetStreamingContext<string>(ContextConstants.SOFT_PERIOD);
var lcTransactionCode = R_Utility.R_GetStreamingContext<string>(ContextConstants.TRANSACTION_CODE);
```

### Violations
- ❌ Setting CCOMPANY_ID, CUSER_ID, CLANG_ID in streaming context
- ❌ Not using ContextConstants for custom parameters
- ❌ Manual parameter passing instead of R_BackGlobalVar

## RULE 28: NULLABLE REFERENCE HANDLING - MANDATORY
**CRITICAL:** All nullable reference types must be handled properly

### Nullable Handling Rules
- **Nullable Checks:** Always check for null before method calls
- **Nullable Properties:** Use `?` for nullable properties (`R_Grid? _gridRef`)
- **No Unnecessary Casting:** Avoid unnecessary type conversions
- **Safe Navigation:** Use null-conditional operators when appropriate

### Correct Pattern
```csharp
// ✅ CORRECT - Nullable checks
if (_gridRef != null)
{
    await _gridRef.R_Refresh();
}

// ✅ CORRECT - Nullable properties
private R_Grid<DTO>? _gridRef;
private R_TextBox? _txtField;
```

### Wrong Pattern
```csharp
// ❌ WRONG - No null check
await _gridRef.R_Refresh(); // Could throw NullReferenceException

// ❌ WRONG - Unnecessary casting
var loGrid = (R_Grid<DTO>)_gridRef; // Could throw InvalidCastException
```

### Violations
- ❌ Not checking for null before method calls
- ❌ Unnecessary casting or type conversions
- ❌ Missing nullable reference type annotations

## RULE 29: CONTEXT CONSTANTS NAMING - MANDATORY
**CRITICAL:** All context constants must use "{ProgramName}_" prefix in the **values** for namespace collision avoidance

### Context Constants Pattern
```csharp
public static class ContextConstants
{
    /// <summary>
    /// Soft period context key
    /// </summary>
    public const string SOFT_PERIOD = "{ProgramName}_CSOFT_PERIOD";

    /// <summary>
    /// Department code context key
    /// </summary>
    public const string DEPT_CODE = "{ProgramName}_CDEPT_CODE";
}
```

### Requirements
- **MUST:** Use exact program name prefix in the **string values** (e.g., `"FAI00130_CSOFT_PERIOD"`)
- **MUST:** Keep variable names simple and descriptive (e.g., `SOFT_PERIOD`, `DEPT_CODE`)
- **MUST:** Document each constant with XML comments
- **NEVER:** Use generic values without program prefix
- **NEVER:** Change the database field names in the prefix

### Violations
- ❌ Using generic values like `"CSOFT_PERIOD"` instead of `"FAI00130_CSOFT_PERIOD"`
- ❌ Missing XML documentation for constants
- ❌ Using program prefix in variable names instead of values

## RULE 30: BUSINESS LOGIC PRESERVATION - NON-NEGOTIABLE
**CRITICAL:** Even if VB.NET code has subtle bugs, we must replicate it exactly

### Business Logic Rules
- **Exact Replication:** VB.NET logic = C# logic (behavioral parity)
- **Bug Preservation:** If VB.NET has bugs, replicate them exactly
- **No "Improvements":** Don't fix bugs during migration
- **Parameter Access:** Match VB.NET parameter access patterns exactly

### Correct Pattern
```csharp
// VB.NET: loRtn.CDEFAULT_TRX_DEPT_CODE = .CTRANS_DEPT_CODE (from parameter)
// C#: Must match exactly
CDEFAULT_TRX_DEPT_CODE = poParameter.CTRANS_DEPT_CODE; // From parameter
```

### Violations
- ❌ "Fixing" bugs during migration
- ❌ Changing calculation algorithms
- ❌ Modifying business logic flow
- ❌ "Improving" VB.NET code

## RULE 31: DTO DESIGN PATTERNS - MANDATORY
**CRITICAL:** Each method gets its own specific parameter DTO, not generic DTOs

### DTO Design Rules
- **Specific Parameter DTOs:** Each method gets its own parameter DTO
- **Property Naming:** Must match VB.NET exactly (`CTRANS_DEPT_CODE`, not `TransDeptCode`)
- **Required Properties:** All properties that VB.NET accesses must exist in C# DTOs
- **Default Values:** Use `string.Empty` for string properties to avoid null issues

### Correct Pattern
```csharp
// ✅ CORRECT - Specific parameter DTO
public class FAI00130GetSystemVariablesParameterDTO
{
    public string CCOMPANY_ID { get; set; } = string.Empty;
    public string CUSER_ID { get; set; } = string.Empty;
    public string CTRANS_DEPT_CODE { get; set; } = string.Empty;
}

// ❌ WRONG - Generic DTO for everything
public class FAI00130DTO // Used for all parameters
```

### Violations
- ❌ Using generic `{ProgramName}DTO` for all parameters
- ❌ Missing properties that VB.NET accesses
- ❌ Using PascalCase instead of VB.NET naming (`CTRANS_DEPT_CODE`)

## RULE 32: STREAMING PATTERN NO PARAMETERS - MANDATORY
**CRITICAL:** IAsyncEnumerable methods must have NO parameters in interface/controller

### Streaming Pattern Rules
- **Interface Methods:** `IAsyncEnumerable<DTO> Method()` (NO parameters)
- **Controller Methods:** `public async IAsyncEnumerable<DTO> Method()` (NO parameters)
- **Parameter Source:** Parameters come from streaming context, not method parameters
- **Controller Logic:** Create parameter DTO internally, populate from streaming context

### Correct Pattern
```csharp
// ✅ CORRECT - Interface with NO parameters
public interface IFAI00020 : R_IServiceCRUDAsyncBase<FAI00020DTO>
{
    IAsyncEnumerable<FAI00020GridDTO> GetJournalDetailList(); // NO parameters
}

// ✅ CORRECT - Controller with NO parameters
[HttpPost]
public async IAsyncEnumerable<FAI00020GridDTO> GetJournalDetailList()
{
    // Create parameter DTO internally
    var loParam = new FAI00020GetJournalDetailParameterDTO
    {
        CCOMPANY_ID = R_BackGlobalVar.COMPANY_ID,
        CDEPT_CODE = R_Utility.R_GetStreamingContext<string>("CDEPT_CODE") ?? string.Empty,
        CTRANSACTION_CODE = R_Utility.R_GetStreamingContext<string>("CTRANSACTION_CODE") ?? string.Empty
    };
    
    var loResult = await loCls.GetJournalDetailListAsync(loParam);
    foreach (var loItem in loResult)
    {
        yield return loItem;
    }
}
```

### Wrong Pattern
```csharp
// ❌ WRONG - Interface with parameters
IAsyncEnumerable<FAI00020GridDTO> GetJournalDetailList(FAI00020GetJournalDetailParameterDTO poParameter);

// ❌ WRONG - Controller with parameters
[HttpPost]
public async IAsyncEnumerable<FAI00020GridDTO> GetJournalDetailList(FAI00020GetJournalDetailParameterDTO poParameter)
```

### Violations
- ❌ Adding parameters to IAsyncEnumerable interface methods
- ❌ Adding parameters to IAsyncEnumerable controller methods
- ❌ Using method parameters instead of streaming context
- ❌ Breaking the streaming pattern architecture

## RULE 33: QUERY LOGGING MANDATORY - NON-NEGOTIABLE
**CRITICAL:** ALL SqlExecQueryAsync and SqlExecNonQueryAsync calls MUST log query and parameters first

### Correct Pattern
```csharp
// ✅ CORRECT - Log query and parameters before execution
_logger.LogInfo("Executing query: {Query}", loCmd.CommandText);
_logger.LogInfo("Parameters: {Parameters}", string.Join(", ", loCmd.Parameters.Cast<DbParameter>().Select(p => $"{p.ParameterName}={p.Value}")));

var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, true);
```

### Wrong Pattern
```csharp
// ❌ WRONG - No logging before execution
var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, true);
```

### Requirements
- **Log CommandText**: Always log the SQL query being executed
- **Log Parameters**: Always log parameter names and values
- **Before Execution**: Logging must happen BEFORE SqlExecQueryAsync/SqlExecNonQueryAsync
- **All Queries**: Both SELECT and INSERT/UPDATE/DELETE queries

### Violations
- ❌ Executing SqlExecQueryAsync without query logging
- ❌ Executing SqlExecNonQueryAsync without parameter logging
- ❌ Logging after execution instead of before
- ❌ Missing parameter value logging

## RULE 34: BUILD AND REFERENCE MANAGEMENT - MANDATORY
**CRITICAL:** Rebuild required after DTO changes to ensure proper references

### Build Management Rules
- **After DTO Changes**: Must rebuild Common project first
- **Reference Updates**: Other projects automatically get updated DTOs
- **Build Order**: Common → BackResources → Back → Service (Backend)
- **Build Order**: Common → FrontResources → Model → Front (Frontend)

### Correct Pattern
```bash
# ✅ CORRECT - Rebuild after DTO changes
dotnet build "{ProgramName}Common"  # First - DTOs updated
dotnet build "{ProgramName}BackResources"
dotnet build "{ProgramName}Back"
dotnet build "{ProgramName}Service"
```

### Wrong Pattern
```bash
# ❌ WRONG - Skip Common rebuild after DTO changes
dotnet build "{ProgramName}Back"  # Will fail - DTOs not updated
```

### Violations
- ❌ Not rebuilding Common after DTO changes
- ❌ Building projects out of order
- ❌ Skipping rebuild after interface changes

## RULE 35: DON'T MODIFY SQL QUERIES OR STORED PROCEDURE NAMES - NON-NEGOTIABLE
**CRITICAL:** SQL queries and stored procedure names MUST remain exactly the same

### Immutable SQL Requirements
- **Stored Procedure Names**: Never change SP names
- **SQL Query Text**: Never modify SQL statements
- **Parameter Names**: Keep exact same parameter names
- **Table/Column Names**: Never change database object names

### Correct Pattern
```csharp
// ✅ CORRECT - Exact same SP name and parameters
loDb.R_AddCommandParameter(loCmd, "@CCOMPANY_ID", DbType.String, 2, lcCompanyId);
loDb.R_AddCommandParameter(loCmd, "@CUSER_ID", DbType.String, 8, lcUserId);
var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, true);
```

### Wrong Pattern
```csharp
// ❌ WRONG - Changed SP name or parameters
loDb.R_AddCommandParameter(loCmd, "@CompanyId", DbType.String, 2, lcCompanyId);  // Changed parameter name
// Changed SP name from "SP_FAI00130_GetSystemVariables" to "GetSystemVariables"
```

### Violations
- ❌ Changing stored procedure names
- ❌ Modifying SQL query text
- ❌ Changing parameter names
- ❌ Altering table or column references

## RULE 36: DON'T CHANGE BUSINESS LOGIC CALCULATIONS - NON-NEGOTIABLE
**CRITICAL:** Business logic calculations MUST remain exactly the same as VB.NET

### Calculation Preservation Rules
- **Exact Formulas**: Replicate VB.NET calculations exactly
- **Rounding Rules**: Use same rounding logic
- **Data Types**: Use same data types for calculations
- **Order of Operations**: Maintain exact calculation order

### Correct Pattern
```csharp
// ✅ CORRECT - Exact same calculation as VB.NET
decimal lcDepreciationAmount = (lcAssetCost - lcSalvageValue) / lcUsefulLife;
decimal lcAccumulatedDepreciation = lcDepreciationAmount * lcPeriodsElapsed;
```

### Wrong Pattern
```csharp
// ❌ WRONG - Changed calculation logic
decimal lcDepreciationAmount = lcAssetCost / lcUsefulLife;  // Removed salvage value
decimal lcAccumulatedDepreciation = Math.Round(lcDepreciationAmount * lcPeriodsElapsed, 2);  // Added rounding
```

### Violations
- ❌ Changing calculation formulas
- ❌ Adding or removing rounding
- ❌ Modifying data types for calculations
- ❌ Changing order of operations

## RULE 37: COMPONENT PARAMETER VALIDATION - MANDATORY
**CRITICAL:** All component parameters must be validated before use

### Component Parameter Rules
- **R_ComboBox:** Use `Data` (NOT `DataSource`), use `@bind-Value` by default
- **R_Grid:** Correct `R_GridType` based on usage (Original/Navigator)
- **R_Conductor:** Only for CRUD operations, NOT inquiry programs
- **Parameter Validation:** Check working examples before guessing parameters

### Correct Pattern
```razor
<!-- ✅ CORRECT - R_ComboBox parameters -->
<R_ComboBox Data="@viewModel.DataList"
            @bind-Value="@viewModel.SelectedValue"
            ValueField="@nameof(DTO.PropertyName)"
            TextField="@nameof(DTO.DisplayName)">
</R_ComboBox>

<!-- ✅ CORRECT - R_Grid inquiry (no conductor) -->
<R_Grid @ref="@_gridRef"
        DataSource="@viewModel.DataList"
        R_GridType="@R_eGridType.Original"
        R_ServiceGetListRecord="@Grid_ServiceGetListRecord">
</R_Grid>
```

### Wrong Pattern
```razor
<!-- ❌ WRONG - R_ComboBox with DataSource -->
<R_ComboBox DataSource="@viewModel.DataList" />

<!-- ❌ WRONG - R_Conductor for inquiry program -->
<R_Conductor @ref="@_conductorRef">
    <R_Grid R_GridType="@R_eGridType.Navigator" />
</R_Conductor>
```

### Violations
- ❌ Using `DataSource` instead of `Data` for R_ComboBox
- ❌ Using R_Conductor for inquiry-only programs
- ❌ Wrong R_GridType for the use case
- ❌ Guessing component parameters without checking examples

## RULE 38: FRONT PROJECT .CSPROJ TEMPLATE - MANDATORY
**CRITICAL:** All Front projects MUST use the correct .csproj template structure

### Correct Front Project Template
```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<LangVersion>10.0</LangVersion>
		<Nullable>enable</Nullable>
		<ImplicitUsings>disable</ImplicitUsings>
	</PropertyGroup>

	<ItemGroup>
		<SupportedPlatform Include="browser" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.AspNetCore.Components.Web" Version="6.0.36" />
	</ItemGroup>

	<!-- R_* DLL References with HintPath -->
	<ItemGroup>
		<Reference Include="R_APICommonDTO">
			<HintPath>..\..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_APICommonDTO.dll</HintPath>
		</Reference>
		<Reference Include="R_CommonFrontBackAPI">
			<HintPath>..\..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_CommonFrontBackAPI.dll</HintPath>
		</Reference>
		<Reference Include="R_BlazorFrontEnd">
			<HintPath>..\..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_BlazorFrontEnd.dll</HintPath>
		</Reference>
		<Reference Include="R_BlazorFrontEnd.Controls">
			<HintPath>..\..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_BlazorFrontEnd.Controls.dll</HintPath>
		</Reference>
		<Reference Include="BlazorClientHelper">
			<HintPath>..\..\..\..\SYSTEM\SOURCE\LIBRARY\Menu\BlazorClientHelper.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\{ProgramName}Model\{ProgramName}Model.csproj" />
		<ProjectReference Include="..\{ProgramName}FrontResources\{ProgramName}FrontResources.csproj" />
	</ItemGroup>

</Project>
```

### Key Differences from Backend Projects
- **SDK**: `Microsoft.NET.Sdk.Razor` (NOT `Microsoft.NET.Sdk`)
- **SupportedPlatform**: `<SupportedPlatform Include="browser" />` (REQUIRED)
- **PackageReference**: `Microsoft.AspNetCore.Components.Web` (REQUIRED)
- **NO FrameworkReference**: Use PackageReference instead

### Violations
- ❌ Using `Microsoft.NET.Sdk` instead of `Microsoft.NET.Sdk.Razor`
- ❌ Missing `<SupportedPlatform Include="browser" />`
- ❌ Missing `Microsoft.AspNetCore.Components.Web` package reference
- ❌ Using FrameworkReference instead of PackageReference

## RULE 39: R_BUTTON CHILDCONTENT PATTERN - MANDATORY
**CRITICAL:** R_Button components MUST use ChildContent, NOT Text parameter

### Correct Pattern
```razor
<!-- ✅ CORRECT -->
<R_Button OnClick="OnRefreshClicked">
    @Localizer["btnRefresh"]
</R_Button>

<R_Button OnClick="OnLookupDepartmentClicked">
    ...
</R_Button>
```

### Wrong Pattern
```razor
<!-- ❌ WRONG -->
<R_Button Text="@Localizer["btnRefresh"]" OnClick="OnRefreshClicked" />
<R_Button Text="..." OnClick="OnLookupDepartmentClicked" />
```

### Requirements
- **NO `Text` parameter** - R_Button doesn't have this parameter
- **USE ChildContent** - Content goes between opening and closing tags
- **Localizer as ChildContent** - `@Localizer["key"]` goes inside the button tags

### Violations
- ❌ Using `Text` parameter on R_Button components
- ❌ Not using ChildContent for button text
- ❌ Incorrect Localizer usage in button attributes

## RULE 40: R_LOOKUP LAYOUT PATTERN - MANDATORY
**CRITICAL:** R_Lookup components MUST be wrapped in R_ItemLayout with auto="true"

### Correct Pattern
```razor
<R_ItemLayout auto="true">
    <R_Lookup R_ConductorSource="@_conductorRef"
              R_Before_Open_Lookup="R_Before_Open_LookupDepartment"
              R_After_Open_Lookup="R_After_Open_LookupDepartment"
              R_EnableAdd="true"
              R_EnableEdit="true">
        ...
    </R_Lookup>
</R_ItemLayout>
```

### Wrong Patterns
```razor
<!-- ❌ WRONG - Fixed width -->
<R_ItemLayout Style="width:25px">
    <R_Lookup>...</R_Lookup>
</R_ItemLayout>

<!-- ❌ WRONG - Column-based -->
<R_ItemLayout col="1">
    <R_Lookup>...</R_Lookup>
</R_ItemLayout>

<!-- ❌ WRONG - No wrapper -->
<R_Lookup>...</R_Lookup>
```

### Requirements
- **MUST wrap in R_ItemLayout** - Never use R_Lookup directly in R_StackLayout
- **MUST use auto="true"** - Ensures fit-content behavior
- **NO fixed width** - Avoid `Style="width:25px"` or `col="1"` patterns

### Violations
- ❌ Using R_Lookup without R_ItemLayout wrapper
- ❌ Using fixed width instead of auto="true"
- ❌ Using column-based sizing instead of fit-content

## RULE 41: COLUMN LAYOUT VALIDATION - MANDATORY
**CRITICAL:** Each R_StackLayout Row must have column sum ≤ 12

### Correct Pattern
```razor
<!-- ✅ CORRECT - Each row sums to ≤ 12 -->
<R_StackLayout>
    <!-- Row 1: 2 + 1 + 1 + 4 = 8 columns ✅ -->
    <R_StackLayout Row="true">
        <R_ItemLayout col="2">Label</R_ItemLayout>
        <R_ItemLayout col="1">TextBox</R_ItemLayout>
        <R_ItemLayout col="1">Button</R_ItemLayout>
        <R_ItemLayout col="4">Description</R_ItemLayout>
    </R_StackLayout>
    
    <!-- Row 2: 2 + 1 + 1 + 2 = 6 columns ✅ -->
    <R_StackLayout Row="true">
        <R_ItemLayout col="2">Label</R_ItemLayout>
        <R_ItemLayout col="1">ComboBox</R_ItemLayout>
        <R_ItemLayout col="1">NumericTextBox</R_ItemLayout>
        <R_ItemLayout col="2">Button</R_ItemLayout>
    </R_StackLayout>
</R_StackLayout>
```

### Wrong Pattern
```razor
<!-- ❌ WRONG - Single R_StackLayout with Row="true" -->
<R_StackLayout Row="true">
    <R_ItemLayout col="2">Label</R_ItemLayout>
    <R_ItemLayout col="1">TextBox</R_ItemLayout>
    <R_ItemLayout col="1">Button</R_ItemLayout>
    <R_ItemLayout col="4">Description</R_ItemLayout>
    <!-- This creates one long row instead of separate rows -->
</R_StackLayout>
```

### Requirements
- **Nested R_StackLayout** - Use individual `R_StackLayout Row="true"` for each row
- **Column validation** - Sum of col values per row ≤ 12
- **Last R_ItemLayout** - Use `auto="false"` to prevent overflow

### Violations
- ❌ Using single R_StackLayout Row="true" for multiple rows
- ❌ Column sum exceeding 12 in any row
- ❌ Not using nested R_StackLayout for proper row separation

## RULE 42: USING STATEMENTS ORGANIZATION - MANDATORY
**CRITICAL:** All using statements MUST be in _Imports.razor, NOT in .razor files

### Correct Pattern
```razor
<!-- ✅ CORRECT - In _Imports.razor -->
@using Microsoft.AspNetCore.Components.Web
@using R_BlazorFrontEnd.Controls.Base
@using R_BlazorFrontEnd.Controls
@using R_BlazorFrontEnd.Controls.Layouts
@using R_BlazorFrontEnd.Interfaces
@using R_BlazorFrontEnd.Controls.Grid.Columns
@using R_BlazorFrontEnd.Controls.Forms
@using R_BlazorFrontEnd.Controls.Attributes
@using R_BlazorFrontEnd.Controls.DataControls
@using R_BlazorFrontEnd.Controls.Enums
@using R_BlazorFrontEnd.Controls.Events
@using R_BlazorFrontEnd.Controls.MessageBox
@using R_BlazorFrontEnd.Helpers
@using R_BlazorFrontEnd.Exceptions
@using R_CommonFrontBackAPI
@using BlazorClientHelper
@using FAI00130Model.VMs
@using FAI00130Common.DTOs
@using FAI00130FrontResources
```

```razor
<!-- ✅ CORRECT - In .razor file -->
@page "/FAI00130"
@attribute [R_Page(Title = "Asset Outstanding Depreciation")]
@inherits R_Page

<R_StackLayout>
    <!-- Content only -->
</R_StackLayout>
```

### Wrong Pattern
```razor
<!-- ❌ WRONG - In .razor file -->
@page "/FAI00130"
@using FAI00130Model.VMs
@using FAI00130Common.DTOs
@using FAI00130FrontResources
@attribute [R_Page(Title = "Asset Outstanding Depreciation")]
@inherits R_Page
```

### Requirements
- **NO @using in .razor files** - All imports go in _Imports.razor
- **Clean .razor files** - Only page directives and content
- **Centralized imports** - Easier maintenance and consistency

### Violations
- ❌ Using @using statements in .razor files
- ❌ Duplicating using statements across multiple files
- ❌ Not centralizing imports in _Imports.razor

## RULE 43: MESSAGEBOXSERVICE IMPLEMENTATION - MANDATORY
**CRITICAL:** MessageBoxService MUST use correct namespace and injection pattern

### Correct Pattern
```csharp
// ✅ CORRECT using statement
using R_BlazorFrontEnd.Controls.MessageBox;

// ✅ CORRECT injection
[Inject] public R_MessageBoxService MessageBoxService { get; set; } = default!;

// ✅ CORRECT usage
await MessageBoxService.Show("Error", Localizer["PS003"], R_eMessageBoxButtonType.OK);
```

### Wrong Patterns
```csharp
// ❌ WRONG - Incorrect namespace
using R_BlazorFrontEnd.Services;

// ❌ WRONG - Private injection
[Inject] private R_MessageBoxService MessageBoxService { get; set; } = default!;

// ❌ WRONG - Hardcoded message
await MessageBoxService.Show("Error", "Invalid depreciation period format", R_eMessageBoxButtonType.OK);
```

### Requirements
- **Namespace**: `R_BlazorFrontEnd.Controls.MessageBox`
- **Assembly**: `R_BlazorFrontEnd.Controls`
- **Injection**: Public property with `= default!`
- **Usage**: `Show(title, message, buttonType)`

### Violations
- ❌ Using incorrect namespace for MessageBoxService
- ❌ Using private injection instead of public
- ❌ Using hardcoded messages instead of Localizer

## RULE 44: LOCALIZER INTEGRATION PATTERN - MANDATORY
**CRITICAL:** Localizer MUST be injected in code-behind and used consistently

### Correct Pattern
```csharp
// ✅ CORRECT injection in .razor.cs
[Inject] private R_ILocalizer<FAI00130FrontResources.Resources_Dummy_Class> Localizer { get; set; } = default!;

// ✅ CORRECT using statement
using R_BlazorFrontEnd.Interfaces;
```

```razor
<!-- ✅ CORRECT usage in .razor -->
<R_Label>@Localizer["AssetDepartment"]</R_Label>
<R_Button OnClick="OnRefreshClicked">
    @Localizer["btnRefresh"]
</R_Button>
```

### Wrong Patterns
```csharp
// ❌ WRONG - Injection in ViewModel
public class FAI00130ViewModel
{
    [Inject] private R_ILocalizer<FAI00130FrontResources.Resources_Dummy_Class> Localizer { get; set; } = default!;
}

// ❌ WRONG - Missing using statement
// Missing: using R_BlazorFrontEnd.Interfaces;
```

```razor
<!-- ❌ WRONG - Hardcoded strings -->
<R_Label>Asset Department</R_Label>
<R_Button OnClick="OnRefreshClicked">
    Refresh
</R_Button>
```

### Requirements
- **Injection in code-behind** - NOT in ViewModel
- **Using statement**: `R_BlazorFrontEnd.Interfaces`
- **Consistent usage** - All UI text from Localizer
- **NO hardcoded strings** - Everything from resource files

### Violations
- ❌ Injecting Localizer in ViewModel instead of code-behind
- ❌ Missing R_BlazorFrontEnd.Interfaces using statement
- ❌ Using hardcoded strings instead of Localizer
- ❌ Inconsistent Localizer usage across components

## RULE 45: ERROR MESSAGES FROM RESOURCES - MANDATORY
**CRITICAL:** All error messages MUST come from resource files, never hardcoded

### Correct Pattern
```csharp
// ✅ CORRECT - Error message from resources
var lcErrorMessage = R_Utility.R_GetError(typeof(Resources_Dummy_Class), "ERR_INVALID_COMPANY_ID");
throw new R_Exception(lcErrorMessage);
```

### Wrong Pattern
```csharp
// ❌ WRONG - Hardcoded error message
throw new R_Exception("Invalid company ID");
```

### Requirements
- **All messages in .resx files** - Never hardcode error messages
- **Use R_Utility.R_GetError()** - Retrieve messages from resources
- **Consistent error keys** - Use descriptive error key names
- **Localization support** - Messages can be translated

### Violations
- ❌ Using hardcoded error messages
- ❌ Not using R_Utility.R_GetError() method
- ❌ Missing error keys in resource files
- ❌ Inconsistent error message patterns
