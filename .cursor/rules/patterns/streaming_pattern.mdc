---
description: "Streaming pattern in ViewModel, Model, and Back Project (MUST FOLLOW EXACTLY)"
alwaysApply: false
globs: "*ToCSharpViewModel*","*ToCSharpModel*","*ToCSharpService*"
priority: CRITICAL
nonNegotiable: true
---

# STREAMING PATTERN

## Method Naming
- Interface: `GetStreamingList()`
- Implementation: `GetStreamingListAsync()`

## Parameter Handling
- Use `R_BackGlobalVar` for CompanyId/UserId
- Use `R_FrontContext.R_SetStreamingContext()` for custom parameters
- Retrieve via `R_Utility.R_GetStreamingContext<Type>(ContextConstant.Key)`

### ✅ Correct Controller
```csharp
[HttpPost]
public async IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()
{
    var lcMethod = nameof(GetStreamingList);
    using var activity = _activitySource.StartActivity(lcMethod);
    var loEx = new R_Exception();
    var loCls = new {ProgramName}Cls();
    List<GetStreamingListResultDTO> loResult = new();

    try
    {
        var loParam = new {ProgramName}GetStreamingListParameterDTO
        {
            CCOMPANY_ID = R_BackGlobalVar.COMPANY_ID,
            CDEPT_CODE = R_Utility.R_GetStreamingContext<string>(ContextConstants.DEPT_CODE) ?? string.Empty,
            CTRANSACTION_CODE = R_Utility.R_GetStreamingContext<string>(ContextConstants.TRANSACTION_CODE) ?? string.Empty
        };

        loResult = await loCls.GetStreamingList(loParam);
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
        _logger.LogError(loEx);
    }

    loEx.ThrowExceptionIfErrors();
    foreach (var loItem in loResult)
        yield return loItem;
}
````

### ✅ Correct ViewModel

```csharp
public ObservableCollection<GetStreamingListResultDTO> StreamingList = new();

public async Task GetStreamingListAsync(GetStreamingListParameterDTO poParameter)
{
    var loEx = new R_Exception();
    try
    {
        R_FrontContext.R_SetStreamingContext("OTHER_PARAM_KEY", poParameter.OTHER_PARAM_KEY);
        var loResult = await _model.GetStreamingListAsync();
        StreamingList = new ObservableCollection<GetStreamingListResultDTO>(loResult.Data ?? new());
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }
    loEx.ThrowExceptionIfErrors();
}
```

### ✅ Correct Model

```csharp
public IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()
{
    throw new NotImplementedException();
}

public async Task<{ProgramName}ResultDTO<List<GetStreamingListResultDTO>>> GetStreamingListAsync()
{
    var loEx = new R_Exception();
    var loRtn = new {ProgramName}ResultDTO<List<GetStreamingListResultDTO>>();
    try
    {
        R_HTTPClientWrapper.httpClientName = _HttpClientName;
        loRtn.Data = await R_HTTPClientWrapper.R_APIRequestStreamingObject<GetStreamingListResultDTO>(
            _RequestServiceEndPoint,
            nameof(I{ProgramName}.GetStreamingList),
            _ModuleName,
            true,
            true);
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }
    loEx.ThrowExceptionIfErrors();
    return loRtn;
}
```

#### Benefits

* Consistent
* Scalable
* Maintainable
* Memory-efficient