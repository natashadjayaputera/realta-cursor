---
alwaysApply: false
priority: HIGH
glob: "*ToCSharpBack*"
---

# BACK LAYER PATTERNS

## DLL References (Minimal)
```xml
<ItemGroup>
  <Reference Include="R_APIBackEnd">
    <HintPath>..\..\..\..\..\SYSTEM\SOURCE\LIBRARY\Back\R_APIBackEnd.dll</HintPath>
  </Reference>
  <Reference Include="R_APICommon">
    <HintPath>..\..\..\..\..\SYSTEM\SOURCE\LIBRARY\Back\R_APICommon.dll</HintPath>
  </Reference>
  <Reference Include="R_APICommonDTO">
    <HintPath>..\..\..\..\..\SYSTEM\SOURCE\LIBRARY\Back\R_APICommonDTO.dll</HintPath>
  </Reference>
  <Reference Include="R_CommonFrontBackAPI">
    <HintPath>..\..\..\..\..\SYSTEM\SOURCE\LIBRARY\Back\R_CommonFrontBackAPI.dll</HintPath>
  </Reference>
  <Reference Include="R_OpenTelemetry">
    <HintPath>..\..\..\..\..\SYSTEM\SOURCE\LIBRARY\Back\R_OpenTelemetry.dll</HintPath>
  </Reference>
</ItemGroup>
```

## Project References
```xml
<ItemGroup>
  <ProjectReference Include="..\..\..\COMMON\{module}\{ProgramName}Common\{ProgramName}Common.csproj" />
  <ProjectReference Include="..\{ProgramName}BackResources\{ProgramName}BackResources.csproj" />
</ItemGroup>
```

## Minimal Using Statements (MANDATORY)
```csharp
using System;                    // For basic types (Exception, DateTime, etc.)
using System.Data;               // For DbType
using System.Data.Common;        // For DbConnection, DbCommand, DbParameter
using System.Threading.Tasks;    // For async/await
using System.Collections.Generic; // For List<>, Dictionary<>
using System.Linq;               // For LINQ operations (Cast, Where, ToDictionary)
using R_BackEnd;                 // For R_BusinessObjectAsync, R_Db, R_Utility
using R_Common;                  // For R_Exception
using R_CommonFrontBackAPI;      // For eCRUDMode
using {ProgramName}BackResources; // For resource access
using {ProgramName}Common.DTOs;   // For DTOs
using System.Transactions;       // For TransactionScope (if needed)
using System.Diagnostics;        // For ActivitySource
```

## Logger Pattern (MUST FOLLOW)
```csharp
using R_CommonFrontBackAPI.Log; // Required for R_NetCoreLoggerBase

public class Logger{ProgramName} : R_NetCoreLoggerBase<Logger{ProgramName}>
{
    // Empty - base class provides all functionality
}

## Activity Pattern (MUST FOLLOW)
using R_OpenTelemetry; // Required for R_ActivitySourceBase

public class {ProgramName}Activity : R_ActivitySourceBase
{
    // Empty - base class provides all functionality
}
```

## Business Logic Class Constructor Pattern
```csharp
public class {ProgramName}Cls : R_BusinessObjectAsync<{ProgramName}DTO>
{
    private readonly {ProgramName}BackResources.Resources_Dummy_Class loRsp = new();
    private readonly {RSP_NAME}Resources.Resources_Dummy_Class loRsp = new(); // OPTIONAL: Repeat as much as RSP used
    private readonly Logger{ProgramName} _logger;
    private readonly ActivitySource _activitySource;

    public {ProgramName}Cls()
    {
        _logger = Logger{ProgramName}.R_GetInstanceLogger();
        _activitySource = {ProgramName}Activity.R_GetInstanceActivitySource();
    }
}
```

## Database Pattern 
```csharp
public async Task<ResultDTO> MethodName(ParameterDTO poParam)
{
    string lcMethod = nameof(MethodNameAsync);
    using var activity = _activitySource.StartActivity(lcMethod);
    _logger.LogInfo("START method {MethodName}", lcMethod);

    var loEx = new R_Exception();
    var loDb = new R_Db();
    ResultDTO loResult = new();

    try
    {
        using DbConnection loConn = await loDb.GetConnectionAsync();
        using DbCommand loCmd = loDb.GetCommand();

        loCmd.Parameters.Clear();
        loCmd.CommandText = "SELECT ... FROM ... WHERE ... = @Param";
        loDb.R_AddCommandParameter(loCmd, "@Param", DbType.String, 50, poParam.Value);

        // CRITICAL: Log query and parameters BEFORE execution
        var loDbParams = loCmd.Parameters.Cast<DbParameter>()
            .Where(x => x != null && x.ParameterName.StartsWith("@"))
            .ToDictionary(x => x.ParameterName, x => x.Value);

        _logger.LogDebug("{@ObjectQuery} {@Parameter}", loCmd.CommandText, loDbParams);

        var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, false);
        loResult = R_Utility.R_ConvertTo<ResultDTO>(loDataTable).FirstOrDefault();
        
        // For List results, use .ToList() to convert IList to List
        // var loResultList = R_Utility.R_ConvertTo<ResultDTO>(loDataTable).ToList();
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
        _logger.LogError(loEx);
    }
    finally 
    {
        if (loDb != null) 
            loDb = null;
    }

    loEx.ThrowExceptionIfErrors();
    _logger.LogInfo("END method {MethodName}", lcMethod);

    return loResult;
}
```

## Exception Handling
```csharp
public async Task MethodName()
{
    var loEx = new R_Exception();
    
    try
    {
        // Your code here
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }
    
    loEx.ThrowExceptionIfErrors();
}
```

## Error Retrieval Pattern (CRITICAL)

```csharp
private R_Error GetError(string pcErrorId)
{
    try
    {
        return R_Utility.R_GetError(typeof(Resources_Dummy_Class), pcErrorId);
    }
    catch (Exception)
    {
        throw;
    }
}
```

**Explanation:**

* `pcErrorId` = The message key defined in the resource file (e.g. `"ERR_INVALID_PARAMETER"`).
* `Resources_Dummy_Class` = Dummy class inside the same resource project, used to resolve the namespace for resource lookups.
* The `R_Utility.R_GetError()` method automatically retrieves the localized message text from:

  * `{ProgramName}BackResources_msgrsc.resx` (default)
  * `{ProgramName}BackResources_msgrsc.id.resx` (for Indonesian, etc.)

### ❌ Forbidden Pattern — Hardcoded Messages

**DO NOT:**

```csharp
throw new Exception("Invalid company ID.");
_logger.LogError("User ID not found");
```

### ✅ Correct Pattern — Use Resource-Based Messages

**DO:**

```csharp
R_Exception loEx = new R_Exception();
loEx.Add(GetError("ERR_INVALID_COMPANY_ID"));
_logger.LogError(GetError("ERR_USER_NOT_FOUND"));
```

## Database Parameter Management

### Critical Pattern: Parameter Handling
- **Use**: `loDb.R_AddCommandParameter(loCmd, "@ParameterName", DbType, size, value)` 
- **NOT**: `loCmd.AddDbCommandParameter` (deprecated/incorrect)
- **Always**: Call `loCmd.Parameters.Clear()` before reusing command objects
- **Method signature**: 5 parameters - command object, parameter name, DbType, size (int), value

## R_*Async Override Pattern
**Important Notes:**
- Must throw `NotImplementedException` (not return `Task.CompletedTask`)
- All unused CRUD override methods (R_DeletingAsync, etc.) follow this pattern
- This indicates the operation is not supported for this entity

## Batch Process Placeholder Pattern
When VB.NET class implements R_IBatchProcess:

### Create BatchCls in Back/
```csharp
public class {ProgramName}BatchCls
{
    // TODO: Add logger and activity source when implementing
    // TODO: Implement batch process logic
}
```

## Resource Key Verification Pattern

### Before Creating ANY Resource Key:

**Step 1: Read VB.NET Source**
```vb
' Find in VB.NET code: R_Utility.R_GetError(GetType(Resources_Dummy_Class), "KEY_NAME")
loEx.Add(R_Utility.R_GetError(GetType(Resources_Dummy_Class), "PS001"))
```

**Step 2: Find VB.NET .resx File**
- Location: `net4/.../Back/{ProgramName}BackResources/{ProgramName}BackResources_msgrsc.resx`
- Read ALL resource keys and messages
- Note: Same key may be used in multiple methods

**Step 3: Copy to C# .resx**
```xml
<data name="PS001" xml:space="preserve">
  <value>Exact message from VB.NET resx</value>
</data>
```

**Step 4: Use in C# Code**
```csharp
loEx.Add(GetError("PS001")); // Use EXACT same key as VB.NET
```

**Critical Rules:**
- ✅ Use EXACT key names from VB.NET (e.g., PS001, ERR_001)
- ✅ Copy EXACT error messages
- ✅ If VB.NET reuses key (PS001 in multiple places), reuse in C#
- ❌ NEVER invent new keys
- ❌ NEVER change key names
- ❌ NEVER change error messages
