---
alwaysApply: true
priority: CRITICAL
nonNegotiable: true
---

# CORE PATTERNS - UNIVERSAL

## Streaming Context Pattern (CRITICAL)
**RULE**: For list methods, use streaming context to pass parameters instead of method parameters. This applies to both Controller and ViewModel layers.

#### Method Naming Convention
- **Interface method**: `GetStreamingList()` (e.g., `GetRateTypeStreamingList()`)
- **Implementation method**: `GetStreamingListAsync()` (e.g., `GetRateTypeStreamingListAsync()`)
- **Interface compliance**: `IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()` throws `NotImplementedException`

#### Parameter Handling Rules
- **IClientHelper data** (CompanyId, UserId): Set in Controller using `R_BackGlobalVar`
- **Custom parameters**: Set in ViewModel using `R_FrontContext.R_SetStreamingContext()`
- **Streaming context**: Use `R_Utility.R_GetStreamingContext<Type>(ContextConstant.Key)` in Controller

#### ✅ Correct Controller Pattern
```csharp
[HttpPost]
public async IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()
{
    var lcMethod = nameof(GetStreamingList);
    using var activity = _activitySource.StartActivity(lcMethod);
    var loEx = new R_Exception();
    var loCls = new {ProgramName}Cls();
    List<GetStreamingListResultDTO> loResult = new List<GetStreamingListResultDTO>();

    try
    {
        _logger.LogInfo("Start method GetStreamingList in {0}", lcMethod);

        // Create parameter DTO internally
        var loParam = new {ProgramName}GetStreamingListParameterDTO
        {
            CCOMPANY_ID = R_BackGlobalVar.COMPANY_ID, // NOTE: Global Variable
            CDEPT_CODE = R_Utility.R_GetStreamingContext<string>(ContextConstants.DEPT_CODE) ?? string.Empty,
            CTRANSACTION_CODE = R_Utility.R_GetStreamingContext<string>(ContextConstants.TRANSACTION_CODE) ?? string.Empty
        };

        loResult = await loCls.GetStreamingList(loParam);
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
        _logger.LogError(loEx);
    }

    loEx.ThrowExceptionIfErrors();

    foreach (GetStreamingListResultDTO loItem in loResult)
    {
        yield return loItem;
    }
}
```

#### ✅ Correct ViewModel Pattern
```csharp
public ObservableCollection<GetStreamingListResultDTO> StreamingList = new ObservableCollection<GetStreamingListResultDTO>();

public async Task GetStreamingListAsync(GetStreamingListParameterDTO poParameter)
{
    var loEx = new R_Exception();

    try
    {
        // Set streaming context for non-IClientHelper parameters
        R_FrontContext.R_SetStreamingContext("OTHER_PARAM_KEY", poParameter.OTHER_PARAM_KEY);

        var loResult = await _model.GetStreamingListAsync();

        StreamingList = new ObservableCollection<GetStreamingListResultDTO>(loResult.Data ?? new List<GetStreamingListResultDTO>());
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }

    loEx.ThrowExceptionIfErrors();
}
```

#### ✅ Correct Model Pattern
```csharp
// Streaming patterns - NO parameters
// Interface Implementation Compliance
public IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()
{
    throw new System.NotImplementedException();
}

// Actual Implementation of GetStreamingLis
public async Task<{ProgramName}ResultDTO<List<GetStreamingListResultDTO>>> GetStreamingListAsync()
{
    var loEx = new R_Exception();
    {ProgramName}ResultDTO<List<GetStreamingListResultDTO>> loRtn = new {ProgramName}ResultDTO<List<GetStreamingListResultDTO>>();

    try
    {
        R_HTTPClientWrapper.httpClientName = _HttpClientName;
        loRtn.Data = await R_HTTPClientWrapper.R_APIRequestStreamingObject<GetStreamingListResultDTO>(
            _RequestServiceEndPoint,
            nameof(I{ProgramName}.GetStreamingList),
            _ModuleName,
            true,
            true
        );
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
    }

    loEx.ThrowExceptionIfErrors();
    return loRtn;
}
```

#### Key Benefits of Streaming Context Pattern
1. **Consistency**: All list methods follow the same pattern
2. **Scalability**: Easy to add new parameters without changing method signatures
3. **Maintainability**: Clear separation between IClientHelper and custom parameters
4. **Performance**: Streaming allows for better memory management with large datasets

## ERROR HANDLING PATTERN (Must Follow)

## FRONT & VIEW MODEL DATA STATE SEPARATION - MANDATORY
**CRITICAL:** All data state must be in ViewModel, not in Razor.cs code-behind

### State Management Rules
- **UI State Only in Razor.cs:** Component references (`R_Grid? _gridRef`), UI-specific state
- **Data State in ViewModel:** All business data, form state, tracking variables
- **No Data State in Razor.cs:** Never store business data in code-behind

### Correct Pattern
```csharp
// Razor.cs - UI state only
private R_Grid<DTO>? _gridRef;
private R_TextBox? _txtField;

// ViewModel - All data state
public string FieldValue { get; set; }
public bool MustRefresh { get; set; }
public string LastValue { get; set; }
```

