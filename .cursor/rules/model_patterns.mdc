---
alwaysApply: false
priority: HIGH
glob: "*ToCSharpModel*"
---

# MODEL LAYER PATTERNS

## DLL References
```xml
<ItemGroup>
  <Reference Include="R_APIClient">
    <HintPath>..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_APIClient.dll</HintPath>
  </Reference>
  <Reference Include="R_APICommonDTO">
    <HintPath>..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_APICommonDTO.dll</HintPath>
  </Reference>
  <Reference Include="R_BusinessObjectFront">
    <HintPath>..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_BusinessObjectFront.dll</HintPath>
  </Reference>
  <Reference Include="R_CommonFrontBackAPI">
    <HintPath>..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_CommonFrontBackAPI.dll</HintPath>
  </Reference>
  <Reference Include="R_BlazorFrontEnd">
    <HintPath>..\..\..\SYSTEM\SOURCE\LIBRARY\Front\R_BlazorFrontEnd.dll</HintPath>
  </Reference>
</ItemGroup>
```

## Project References
```xml
<ItemGroup>
  <ProjectReference Include="..\..\COMMON\{module}\{ProgramName}Common\{ProgramName}Common.csproj" />
  <ProjectReference Include="..\{ProgramName}FrontResources\{ProgramName}FrontResources.csproj" />
</ItemGroup>
```

## Model Pattern

### HTTP Client Name Convention
- **Most modules**: `"R_DefaultServiceUrl{ModuleName}"` (e.g., `"R_DefaultServiceUrlFA"` for FA module)
- **GS and SA modules ONLY**: `"R_DefaultServiceUrl"` (no suffix)

```csharp
public class {ProgramName}Model : R_BusinessObjectServiceClientBase<{ProgramName}DTO>, I{ProgramName}
{
    private const string DEFAULT_HTTP_NAME = "R_DefaultServiceUrl{ModuleName}";
    private const string DEFAULT_SERVICEPOINT_NAME = "api/{ProgramName}";
    private const string DEFAULT_MODULE = "{ModuleName}";

    public {ProgramName}Model()
        : base(DEFAULT_HTTP_NAME, DEFAULT_SERVICEPOINT_NAME, DEFAULT_MODULE, true, true)
    {
    }

    // Streaming patterns - NO parameters
    // Interface Implementation Compliance
    public IAsyncEnumerable<GetStreamingListResultDTO> GetStreamingList()
    {
        throw new System.NotImplementedException();
    }

    // Actual Implementation of GetStreamingLis
    public async Task<{ProgramName}ResultDTO<List<GetStreamingListResultDTO>>> GetStreamingListAsync()
    {
        var loEx = new R_Exception();
        {ProgramName}ResultDTO<List<GetStreamingListResultDTO>> loRtn = new {ProgramName}ResultDTO<List<GetStreamingListResultDTO>>();

        try
        {
            R_HTTPClientWrapper.httpClientName = _HttpClientName;
            loRtn.Data = await R_HTTPClientWrapper.R_APIRequestStreamingObject<GetStreamingListResultDTO>(
                _RequestServiceEndPoint,
                nameof(I{ProgramName}.GetStreamingList),
                _ModuleName,
                true,
                true
            );
        }
        catch (Exception ex)
        {
            loEx.Add(ex);
        }

        loEx.ThrowExceptionIfErrors();
        return loRtn;
    }

    // Non-streaming Patterns - WITH parameters
    public async Task<{ProgramName}ResultDTO<GetNonStreamingResultDTO>> GetNonStreaming(GetNonStreamingParameterDTO poParameter)
    {
        var loEx = new R_Exception();
        {ProgramName}ResultDTO<List<GetNonStreamingResultDTO>> loRtn = new {ProgramName}ResultDTO<List<GetNonStreamingResultDTO>>();

        try
        {
            R_HTTPClientWrapper.httpClientName = _HttpClientName;
            loRtn = await R_HTTPClientWrapper.R_APIRequestObject<{ProgramName}ResultDTO<List<GetNonStreamingResultDTO>>, GetNonStreamingParameterDTO>(
                _RequestServiceEndPoint,
                nameof(I{ProgramName}.GetStreamingList),
                poParameter,
                _ModuleName,
                true,
                true
            );
        }
        catch (Exception ex)
        {
            loEx.Add(ex);
        }

        loEx.ThrowExceptionIfErrors();
        return loRtn;
    }

    // Non-streaming Patterns - WITHOUT parameters
    public async Task<{ProgramName}ResultDTO<GetNonStreamingResultDTO>> GetNonStreaming()
    {
        var loEx = new R_Exception();
        {ProgramName}ResultDTO<List<GetNonStreamingResultDTO>> loRtn = new {ProgramName}ResultDTO<List<GetNonStreamingResultDTO>>();

        try
        {
            R_HTTPClientWrapper.httpClientName = _HttpClientName;
            loRtn = await R_HTTPClientWrapper.R_APIRequestObject<{ProgramName}ResultDTO<List<GetNonStreamingResultDTO>>>(
                _RequestServiceEndPoint,
                nameof(I{ProgramName}.GetStreamingList),
                _ModuleName,
                true,
                true
            );
        }
        catch (Exception ex)
        {
            loEx.Add(ex);
        }

        loEx.ThrowExceptionIfErrors();
        return loRtn;
    }
}
```

## ðŸŽ¯ CRITICAL API PATTERN DIFFERENCES

### Non-Streaming vs Streaming Methods
- **Non-streaming**: `R_APIRequestObject<TResult, TParameter>()` returns the **full ResultDTO directly**
  - Assignment: `loRtn = await R_HTTPClientWrapper.R_APIRequestObject<...>()`
  - **NOT** `loRtn.Data = await ...`

- **Streaming**: `R_APIRequestStreamingObject<T>()` returns **just the data**
  - Assignment: `loRtn.Data = await R_HTTPClientWrapper.R_APIRequestStreamingObject<...>()`

### Generic Type Parameters
- **TResult**: Must be the **complete ResultDTO type** (e.g., `FAM00100ResultDTO<int>`)
- **TParameter**: Must be the **ParameterDTO type** (e.g., `FAM00100CheckDataParameterDTO`)
- **NOT** just the inner data type (e.g., `int` or `FAM00100DTO`)

### Common Pitfalls to Avoid
1. **Wrong Assignment Pattern**: Using `.Data` for non-streaming methods
2. **Incorrect Generic Types**: Using inner types instead of full ResultDTO types
3. **Missing Parameters**: Forgetting the 6th parameter to disambiguate method overloads
