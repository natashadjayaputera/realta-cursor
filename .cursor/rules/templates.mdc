---
alwaysApply: true
---

# MANDATORY TEMPLATES - Copy Exactly

## Template 1: Logger Pattern (Back Project ONLY)
```csharp
using R_CommonFrontBackAPI.Log;

namespace {ProgramName}Back
{
    public class Logger{ProgramName} : R_NetCoreLoggerBase<Logger{ProgramName}>
    {
        // Empty - base class provides all functionality
    }
}
```

## Template 2: Activity Pattern (Back Project ONLY)
```csharp
using R_OpenTelemetry;

namespace {ProgramName}Back
{
    public class {ProgramName}Activity : R_ActivitySourceBase
    {
        // Empty - base class provides all functionality
    }
}
```

## Template 3: Interface Pattern
```csharp
public interface I{ProgramName} : R_IServiceCRUDAsyncBase<{ProgramName}DTO>
{
    IAsyncEnumerable<{GetListResultDTO}> GetList{Description}();
    Task<{ProgramName}ResultDTO<{GetAnythingResultDTO}>> GetAnything({GetAnythingParameterDTO} poParameter);
}
```

## Template 4: Database Operation Pattern
```csharp
R_Db? loDb = null;
try
{
    loDb = new R_Db();
    using var loConn = await loDb.GetConnectionAsync();
    using var loCmd = loDb.GetCommand();
    
    loDb.R_AddCommandParameter(loCmd, "@PARAM", DbType.String, size, value);
    var loDataTable = await loDb.SqlExecQueryAsync(loConn, loCmd, true);
}
finally
{
    if (loDb != null) { loDb = null; }
}
```

## Template 5: Service Layer Pattern
```csharp
[HttpPost]
public async IAsyncEnumerable<{ResultDTO}> GetList{Description}()
{
    var lcMethod = nameof(GetList{Description});
    using var activity = _activitySource.StartActivity(lcMethod);
    var loEx = new R_Exception();
    var loCls = new {ProgramName}Cls();
    List<{ResultDTO}> loRtn = new List<{ResultDTO}>();

    try
    {
        var lcCompanyId = R_BackGlobalVar.COMPANY_ID;
        _logger.LogInfo("Start method GetList{Description}Async in {0}", lcMethod);
        loRtn = await loCls.GetList{Description}Async(lcCompanyId);
    }
    catch (Exception ex)
    {
        loEx.Add(ex);
        _logger.LogError(loEx);
    }

    loEx.ThrowExceptionIfErrors();

    foreach ({ResultDTO} loItem in loRtn)
    {
        yield return loItem;
    }
}
```

## Template 6: Model Pattern
```csharp
public class {ProgramName}Model : R_BusinessObjectServiceClientBase<{ProgramName}DTO>, I{ProgramName}
{
    private const string DEFAULT_HTTP_NAME = "R_DefaultServiceUrl{ModuleName}";
    private const string DEFAULT_SERVICEPOINT_NAME = "api/{ProgramName}";
    private const string DEFAULT_MODULE = "{ModuleName}";

    public {ProgramName}Model()
        : base(DEFAULT_HTTP_NAME, DEFAULT_SERVICEPOINT_NAME, DEFAULT_MODULE, true, true)
    {
    }

    public IAsyncEnumerable<{ResultDTO}> GetList{Description}()
    {
        throw new System.NotImplementedException();
    }

    public async Task<{ProgramName}ResultDTO<List<{ResultDTO}>>> GetList{Description}Async()
    {
        var loEx = new R_Exception();
        {ProgramName}ResultDTO<List<{ResultDTO}>> loRtn = new {ProgramName}ResultDTO<List<{ResultDTO}>>();

        try
        {
            R_HTTPClientWrapper.httpClientName = _HttpClientName;
            loRtn.Data = await R_HTTPClientWrapper.R_APIRequestStreamingObject<{ResultDTO}>(
                _RequestServiceEndPoint,
                nameof(I{ProgramName}.GetList{Description}),
                _ModuleName,
                true,
                true
            );
        }
        catch (Exception ex)
        {
            loEx.Add(ex);
        }

        loEx.ThrowExceptionIfErrors();
        return loRtn;
    }
}
```

---

# NOTE: Copy-paste templates exactly. No variations allowed.